diff --git a/src/dns_internal.cc b/src/dns_internal.cc
index 91cf352..eec881c 100644
--- a/src/dns_internal.cc
+++ b/src/dns_internal.cc
@@ -45,6 +45,7 @@
 #include "MemBuf.h"
 #include "util.h"
 #include "wordlist.h"
+#include "base/InstanceId.h"
 
 #if HAVE_ARPA_NAMESER_H
 #include <arpa/nameser.h>
@@ -124,7 +125,9 @@ struct _idns_query {
     char name[NS_MAXDNAME + 1];
     char orig[NS_MAXDNAME + 1];
     ssize_t sz;
-    unsigned short id;
+    unsigned short msg_id; /// random query ID sent to server; changes with every query sent 
+    InstanceId<idns_query> xact_id; /// identifies our "transaction", stays constant when query is retried 
+
     int nsends;
     int need_vc;
 
@@ -145,6 +148,7 @@ struct _idns_query {
         rfc1035_rr *answers;
     } initial_AAAA;
 };
+InstanceIdDefinitions(idns_query,  "dns");
 
 struct _nsvc {
     int ns;
@@ -238,6 +242,7 @@ static PF idnsRead;
 static EVH idnsCheckQueue;
 static void idnsTickleQueue(void);
 static void idnsRcodeCount(int, int);
+static unsigned short idnsQueryID(void);
 
 static void
 idnsAddNameserver(const char *buf)
@@ -660,7 +665,7 @@ idnsStats(StoreEntry * sentry)
     for (n = lru_list.head; n; n = n->next) {
         q = (idns_query *)n->data;
         storeAppendPrintf(sentry, "%#06x %4d %5d %10.3f %9.3f\n",
-                          (int) q->id, (int) q->sz, q->nsends,
+                          (int) q->msg_id, (int) q->sz, q->nsends,
                           tvSubDsec(q->start_t, current_time),
                           tvSubDsec(q->sent_t, current_time));
     }
@@ -887,6 +892,10 @@ idnsSendQuery(idns_query * q)
     int x = -1, y = -1;
     int ns;
 
+    q->start_t = current_time;
+    q->msg_id = idnsQueryID();
+    rfc1035SetQueryID(q->buf, q->msg_id);
+
     do {
         ns = q->nsends % nns;
 
@@ -951,7 +960,7 @@ idnsFindQuery(unsigned short id)
     for (n = lru_list.tail; n; n = n->prev) {
         q = (idns_query*)n->data;
 
-        if (q->id == id)
+        if (q->msg_id == id)
             return q;
     }
 
@@ -1030,7 +1039,7 @@ idnsGrokReply(const char *buf, size_t sz, int from_ns)
         return;
     }
 
-    debugs(78, 3, "idnsGrokReply: ID 0x" << std::hex << message->id << ", " << std::dec << n << " answers");
+    debugs(78, 3, "idnsGrokReply: QID 0x" << std::hex <<   message->id << ", " << std::dec << n << " answers");
 
     q = idnsFindQuery(message->id);
 
@@ -1079,7 +1088,13 @@ idnsGrokReply(const char *buf, size_t sz, int from_ns)
             q->need_vc = 1;
             q->nsends--;
             idnsSendQuery(q);
-        }
+        } else {
+            // Strange: A TCP DNS response with the truncation bit (TC) set.
+            // Return an error and cleanup; no point in trying TCP again.
+            debugs(78, 3, HERE << "TCP DNS response");
+            idnsCallback(q, NULL, 0, "Truncated TCP DNS response");
+            cbdataFree(q);
+         }
 
         return;
     }
@@ -1099,9 +1114,6 @@ idnsGrokReply(const char *buf, size_t sz, int from_ns)
              */
             debugs(78, 3, "idnsGrokReply: Query result: SERV_FAIL");
             rfc1035MessageDestroy(&message);
-            q->start_t = current_time;
-            q->id = idnsQueryID();
-            rfc1035SetQueryID(q->buf, q->id);
             idnsSendQuery(q);
             return;
         }
@@ -1123,15 +1135,12 @@ idnsGrokReply(const char *buf, size_t sz, int from_ns)
 
             idnsDropMessage(message, q);
 
-            q->start_t = current_time;
-            q->id = idnsQueryID();
-            rfc1035SetQueryID(q->buf, q->id);
             if (Ip::EnableIpv6 && q->query.qtype == RFC1035_TYPE_AAAA) {
                 debugs(78, 3, "idnsGrokReply: Trying AAAA Query for " << q->name);
-                q->sz = rfc3596BuildAAAAQuery(q->name, q->buf, sizeof(q->buf), q->id, &q->query);
+                q->sz = rfc3596BuildAAAAQuery(q->name, q->buf, sizeof(q->buf), 0, &q->query);
             } else {
                 debugs(78, 3, "idnsGrokReply: Trying A Query for " << q->name);
-                q->sz = rfc3596BuildAQuery(q->name, q->buf, sizeof(q->buf), q->id, &q->query);
+                q->sz = rfc3596BuildAQuery(q->name, q->buf, sizeof(q->buf), 0, &q->query);
             }
 
             if (q->sz < 0) {
@@ -1167,10 +1176,7 @@ idnsGrokReply(const char *buf, size_t sz, int from_ns)
 
         // reset the query as an A query
         q->nsends = 0;
-        q->start_t = current_time;
-        q->id = idnsQueryID();
-        rfc1035SetQueryID(q->buf, q->id);
-        q->sz = rfc3596BuildAQuery(q->name, q->buf, sizeof(q->buf), q->id, &q->query);
+        q->sz = rfc3596BuildAQuery(q->name, q->buf, sizeof(q->buf), 0, &q->query);
         q->need_A = false;
 
         if (q->sz < 0) {
@@ -1328,15 +1334,18 @@ idnsCheckQueue(void *unused)
             continue;
         }
 
-        debugs(78, 3, "idnsCheckQueue: ID 0x" << std::hex << std::setfill('0') << std::setw(4) << q->id << "timeout" );
+        debugs(78, 3, "idnsCheckQueue: ID " << q->xact_id <<
+               " QID 0x"  << std::hex << std::setfill('0')  <<
+               std::setw(4) << q->msg_id << ": timeout" );
 
         dlinkDelete(&q->lru, &lru_list);
 
         if (tvSubDsec(q->start_t, current_time) < Config.Timeout.idns_query) {
             idnsSendQuery(q);
         } else {
-            debugs(78, 2, "idnsCheckQueue: ID " << std::hex << q->id <<
-                   ": giving up after " << std::dec << q->nsends << " tries and " <<
+            debugs(78, 2, "idnsCheckQueue: ID " << q->xact_id <<
+                   " QID 0x" << std::hex << q->msg_id <<
+                   " : giving up after " << std::dec << q->nsends << " tries and " <<
                    std::setw(5)<< std::setprecision(2) << tvSubDsec(q->start_t, current_time) << " seconds");
 
             if (q->rcode != 0)
@@ -1577,6 +1586,8 @@ idnsCachedLookup(const char *key, IDNSCB * callback, void *data)
         return 0;
 
     q = cbdataAlloc(idns_query);
+    // idns_query is POD so no constructors are called after allocation
+    q->xact_id.change();
 
     q->callback = callback;
 
@@ -1607,8 +1618,8 @@ idnsALookup(const char *name, IDNSCB * callback, void *data)
         return;
 
     q = cbdataAlloc(idns_query);
-
-    q->id = idnsQueryID();
+    // idns_query is POD so no constructors are called after allocation
+    q->xact_id.change();
 
     for (i = 0; i < strlen(name); i++)
         if (name[i] == '.')
@@ -1631,10 +1642,10 @@ idnsALookup(const char *name, IDNSCB * callback, void *data)
     }
 
     if (Ip::EnableIpv6) {
-        q->sz = rfc3596BuildAAAAQuery(q->name, q->buf, sizeof(q->buf), q->id, &q->query);
+        q->sz = rfc3596BuildAAAAQuery(q->name, q->buf, sizeof(q->buf), 0, &q->query);
         q->need_A = true;
     } else {
-        q->sz = rfc3596BuildAQuery(q->name, q->buf, sizeof(q->buf), q->id, &q->query);
+        q->sz = rfc3596BuildAQuery(q->name, q->buf, sizeof(q->buf), 0, &q->query);
         q->need_A = false;
     }
 
@@ -1647,13 +1658,11 @@ idnsALookup(const char *name, IDNSCB * callback, void *data)
     }
 
     debugs(78, 3, "idnsALookup: buf is " << q->sz << " bytes for " << q->name <<
-           ", id = 0x" << std::hex << q->id);
+           ", id = 0x" << std::hex << q->msg_id);
 
     q->callback = callback;
     q->callback_data = cbdataReference(data);
 
-    q->start_t = current_time;
-
     idnsCacheQuery(q);
     idnsSendQuery(q);
 }
@@ -1671,16 +1680,17 @@ idnsPTRLookup(const Ip::Address &addr, IDNSCB * callback, void *data)
 
     q = cbdataAlloc(idns_query);
 
-    q->id = idnsQueryID();
+    // idns_query is POD so no constructors are called after allocation
+    q->xact_id.change();
 
     if (addr.IsIPv6()) {
         struct in6_addr addr6;
         addr.GetInAddr(addr6);
-        q->sz = rfc3596BuildPTRQuery6(addr6, q->buf, sizeof(q->buf), q->id, &q->query);
+        q->sz = rfc3596BuildPTRQuery6(addr6, q->buf, sizeof(q->buf), 0, &q->query);
     } else {
         struct in_addr addr4;
         addr.GetInAddr(addr4);
-        q->sz = rfc3596BuildPTRQuery4(addr4, q->buf, sizeof(q->buf), q->id, &q->query);
+        q->sz = rfc3596BuildPTRQuery4(addr4, q->buf, sizeof(q->buf), 0, &q->query);
     }
 
     /* PTR does not do inbound A/AAAA */
@@ -1700,13 +1710,11 @@ idnsPTRLookup(const Ip::Address &addr, IDNSCB * callback, void *data)
     }
 
     debugs(78, 3, "idnsPTRLookup: buf is " << q->sz << " bytes for " << ip <<
-           ", id = 0x" << std::hex << q->id);
+           ", id = 0x" << std::hex << q->msg_id);
 
     q->callback = callback;
     q->callback_data = cbdataReference(data);
 
-    q->start_t = current_time;
-
     idnsCacheQuery(q);
     idnsSendQuery(q);
 }
diff --git a/src/base/InstanceId.h b/src/base/InstanceId.h
new file mode 100644
index 0000000..db88c54
--- /dev/null
+++ b/src/base/InstanceId.h
@@ -0,0 +1,62 @@
+#ifndef SQUID_BASE_INSTANCE_ID_H
+#define SQUID_BASE_INSTANCE_ID_H
+
+#include "config.h"
+#include <iosfwd>
+
+/** Identifier for class instances
+ *   - unique IDs for a large number of concurrent instances, but may wrap;
+ *   - useful for debugging and insecure request/response matching;
+ *   - sequential IDs within a class except when wrapping;
+ *   - always positive IDs.
+ *  \todo: add storage type parameter to support configurable Value types?
+ *  \todo: add creation/destruction debugging?
+ */
+template <class Class>
+class InstanceId
+{
+public:
+    typedef unsigned int Value; ///< id storage type; \todo: parameterize?
+
+    InstanceId(): value(++Last ? Last : ++Last) {}
+
+    operator Value() const { return value; }
+    bool operator ==(const InstanceId &o) const { return value == o.value; }
+    bool operator !=(const InstanceId &o) const { return !(*this == o); }
+    void change() {value = ++Last ? Last : ++Last;}
+
+    /// prints Prefix followed by ID value; \todo: use HEX for value printing?
+    std::ostream &print(std::ostream &os) const;
+
+public:
+    static const char *Prefix; ///< Class shorthand string for debugging
+    Value value; ///< instance identifier
+
+private:
+    InstanceId(const InstanceId& right); ///< not implemented; IDs are unique
+    InstanceId& operator=(const InstanceId &right); ///< not implemented
+
+private:
+    static Value Last; ///< the last used ID value
+};
+
+/// convenience macro to instantiate Class-specific stuff in .cc files
+#define InstanceIdDefinitions(Class, prefix) \
+    template<> std::ostream & \
+    InstanceId<Class>::print(std::ostream &os) const { \
+        return os << Prefix << value; \
+    } \
+    template<> const char *InstanceId<Class>::Prefix = prefix; \
+    template<> InstanceId<Class>::Value InstanceId<Class>::Last = 0
+
+
+/// print the id
+template <class Class>
+inline
+std::ostream &operator <<(std::ostream &os, const InstanceId<Class> &id)
+{
+    return id.print(os);
+}
+
+
+#endif /* SQUID_BASE_INSTANCE_ID_H */
diff --git a/src/base/Makefile.am b/src/base/Makefile.am
index 7009fb3..72c7f83 100644
--- a/src/base/Makefile.am
+++ b/src/base/Makefile.am
@@ -13,3 +13,5 @@ libbase_la_SOURCES = \
 	AsyncCallQueue.h \
 	CbcPointer.h \
 	TidyPointer.h
+	TidyPointer.h \
+	InstanceId.h
=== modified file 'src/cbdata.cc'
--- a/src/cbdata.cc	2010-11-27 06:44:33 +0000
+++ b/src/cbdata.cc	2011-12-16 09:10:02 +0000
@@ -108,7 +108,7 @@
 
     ~cbdata();
     int valid;
-    int locks;
+    int32_t locks;
     cbdata_type type;
 #if CBDATA_DEBUG
 
@@ -419,7 +419,7 @@
 
     c->check(__LINE__);
 
-    assert(c->locks < 65535);
+    assert(c->locks < INT_MAX);
 
     c->locks++;
 }
